<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016-11-15-postgresql&#39;s-common-table-expressions" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/15/2016-11-15-postgresql's-common-table-expressions/" class="article-date">
  <time datetime="2016-11-15T00:00:00.000Z" itemprop="datePublished">2016-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/postgresql/">postgresql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/2016-11-15-postgresql's-common-table-expressions/">postgresql&#39;s common table expressions</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>WITH语句指定临时命名的结果集，这些结果集称为公用表表达式 (CTE)。 该表达式源自简单查询，并且在单条 SELECT、INSERT、UPDATE 或 DELETE 语句的执行范围内定义。WITH语句通常被用来作为一次查询的临时表而存在，通过使用WITH关键字能够创建辅助的查询语句，对于复杂的查询语句，能够极大的简化逻辑，使得SQL语句更加便于阅读。</p>
<h3 id="CTE’s在查询语句中总是被物化的"><a href="#CTE’s在查询语句中总是被物化的" class="headerlink" title="CTE’s在查询语句中总是被物化的"></a>CTE’s在查询语句中总是被物化的</h3><p>CTE只要被引用一次就会被物化，以后再引用的话就不会重复进行额外的计算。如果一个CTE节点没有被任何地方引用,那么他将不会执行,下面的语句将会正常的输出而不会报错:</p>
<pre><code>WITH not_executed AS (SELECT 1/0),
    executed AS (SELECT 1)
SELECT * FROM executed;
</code></pre><p>但是这条查询会给出一个<code>ERROR: division by zero</code>的错误。</p>
<pre><code>WITH a AS (SELECT 1/0),
b AS (SELECT * FROM a),
executed AS (SELECT 1)
SELECT * FROM executed;
</code></pre><p>目前看来，使用了<code>order by</code>的CTE总是输出排序后的记录,但是不能完全依赖这种特性，可能再未来的某个时候，这项特性会被改掉。而且，如果在外部查询也使用了<code>order by</code>，那么postgresql可能不能正确的排序。</p>
<pre><code>WITH a AS (SELECT x, y FROM big_table ORDER BY x)
SELECT *
FROM a ;
</code></pre><h3 id="CTE没有自动的谓词下推-prediction-pushdown"><a href="#CTE没有自动的谓词下推-prediction-pushdown" class="headerlink" title="CTE没有自动的谓词下推(prediction pushdown)"></a>CTE没有自动的谓词下推(prediction pushdown)</h3><p>优化关系SQL查询的一项基本技术是，将外层查询块的<code>WHERE</code>子句中的谓词移入所包含的较低层查询块（例如视图），从而能够提早进行数据过滤以及有可能更好地利用索引。只要新的查询和旧的查询在逻辑上是等价的，那么最终会返回所有相关的结果，相比较旧的查询，优化后的查询更快。但是在postgresql中，并没有采用这种优化方法，也没有区分只读还是可写的CTE，它再指定执行计划时采取了一种比较保守的做法。由于采用了相对保守的方式，优化器不会将<code>WHERE</code>语句提升到CTE子句中，即使这种做法看起来是安全的。</p>
<p>我们可以等待postgresql团队优化CTE，目前我们能够做的只能改变我们进行sql查询的方式。</p>
<h4 id="1-在查询语句中，硬编码谓词下推后得到的sql"><a href="#1-在查询语句中，硬编码谓词下推后得到的sql" class="headerlink" title="1. 在查询语句中，硬编码谓词下推后得到的sql"></a>1. 在查询语句中，硬编码谓词下推后得到的sql</h4><p>原始的查询语句：</p>
<pre><code>CREATE OR REPLACE FUNCTION suggest_movies(IN query text, IN result_limit integer DEFAULT 5)
  RETURNS TABLE(movie_id integer, title text) AS
$BODY$
WITH suggestions AS (

  SELECT
    actors.name AS entity_term,
    movies.movie_id AS suggestion_id,
    movies.title AS suggestion_title,
    1 AS rank
  FROM actors
  INNER JOIN movies_actors ON (actors.actor_id = movies_actors.actor_id)
  INNER JOIN movies ON (movies.movie_id = movies_actors.movie_id)

  UNION ALL

  SELECT
    searches.title AS entity_term,
    suggestions.movie_id AS suggestion_id,
    suggestions.title AS suggestion_title,
    RANK() OVER (PARTITION BY searches.movie_id ORDER BY cube_distance(searches.genre, suggestions.genre)) AS rank
  FROM movies AS searches
  INNER JOIN movies AS suggestions ON
    (searches.movie_id &lt;&gt; suggestions.movie_id) AND
    (cube_enlarge(searches.genre, 2, 18) @&gt; suggestions.genre)
)
SELECT suggestion_id, suggestion_title
FROM suggestions
WHERE entity_term = query
ORDER BY rank, suggestion_id
LIMIT result_limit;
$BODY$
LANGUAGE sql;
</code></pre><p>将查询过滤的条件移到CTE语句内部：</p>
<pre><code>CREATE OR REPLACE FUNCTION suggest_movies(IN query text, IN result_limit integer DEFAULT 5)
  RETURNS TABLE(movie_id integer, title text) AS
$BODY$
WITH suggestions AS (

  SELECT
    actors.name AS entity_term,
    movies.movie_id AS suggestion_id,
    movies.title AS suggestion_title,
    1 AS rank
  FROM actors
  INNER JOIN movies_actors ON (actors.actor_id = movies_actors.actor_id)
  INNER JOIN movies ON (movies.movie_id = movies_actors.movie_id)
  WHERE actors.name = query

  UNION ALL

  SELECT
    searches.title AS entity_term,
    suggestions.movie_id AS suggestion_id,
    suggestions.title AS suggestion_title,
    RANK() OVER (PARTITION BY searches.movie_id ORDER BY cube_distance(searches.genre, suggestions.genre)) AS rank
  FROM movies AS searches
  INNER JOIN movies AS suggestions ON
    (searches.movie_id &lt;&gt; suggestions.movie_id) AND
    (cube_enlarge(searches.genre, 2, 18) @&gt; suggestions.genre)
  WHERE searches.title = query
)
SELECT suggestion_id, suggestion_title
FROM suggestions
ORDER BY rank, suggestion_id
LIMIT result_limit;
$BODY$
LANGUAGE sql;
</code></pre><p>第一个查询语句会通过两次查询将数据库中相关的表的数据全部查询出来然后组合成一张表，然后再进行过滤。可以看到通过这种方式，数据库返回了很多不必要的数据，更糟糕的是组合的新表由于无法利用索引导致查询的效率更低下。优化后的语句由于将过滤的条件移动到了CTE中，所以会提早的进行过滤处理，从而提高查询的效率。</p>
<h4 id="2-使用子查询"><a href="#2-使用子查询" class="headerlink" title="2. 使用子查询"></a>2. 使用子查询</h4><p>postgresql能够很好的针对子查询语句进行谓词下推的优化，通过这一特性，我们能够编写出效率一样而且更加的易于维护的查询语句。<br>首先准备需要的表结构和数据：</p>
<pre><code>CREATE TABLE a (c INT);

CREATE TABLE b (c INT);

CREATE INDEX a_c ON a(c);

CREATE INDEX b_c ON b(c);

INSERT INTO a SELECT 1 FROM generate_series(1, 1000000);

INSERT INTO b SELECT 2 FROM a;

INSERT INTO a SELECT 3;
</code></pre><p>使用CTE进行查询：</p>
<pre><code>EXPLAIN ANALYZE
WITH cte AS (
  SELECT c FROM a
  UNION ALL
  SELECT c FROM b
)
SELECT c FROM cte WHERE c = 3;
</code></pre><p>查询计划如下：</p>
<pre><code>  QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------
 CTE Scan on cte (cost=28850.00..73850.00 rows=10000 width=4) (actual time=607.968..1138.062 rows=1 loops=1)
  Filter: (c = 3)
  Rows Removed by Filter: 2000000
  CTE cte
  -&gt; Append (cost=0.00..28850.00 rows=2000000 width=4) (actual time=0.013..579.749 rows=2000001 loops=1)
  -&gt; Seq Scan on a (cost=0.00..14425.00 rows=1000000 width=4) (actual time=0.012..142.085 rows=1000001 loops=1)
  -&gt; Seq Scan on b (cost=0.00..14425.00 rows=1000000 width=4) (actual time=0.007..122.516 rows=1000000 loops=1)
 Planning time: 0.284 ms
 Execution time: 1144.234 ms
(9 rows)
</code></pre><p>使用子查询：</p>
<pre><code>EXPLAIN ANALYZE
SELECT c
FROM (
  SELECT c FROM a
  UNION ALL
  SELECT c FROM b
) AS subquery
WHERE c = 3;
</code></pre><p>查询计划如下：</p>
<pre><code>  QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Append (cost=0.42..8.88 rows=2 width=4) (actual time=0.045..0.055 rows=1 loops=1)
  -&gt; Index Only Scan using a_c on a (cost=0.42..4.44 rows=1 width=4) (actual time=0.044..0.045 rows=1 loops=1)
  Index Cond: (c = 3)
  Heap Fetches: 1
  -&gt; Index Only Scan using b_c on b (cost=0.42..4.44 rows=1 width=4) (actual time=0.008..0.008 rows=0 loops=1)
  Index Cond: (c = 3)
  Heap Fetches: 0
 Planning time: 0.163 ms
 Execution time: 0.097 ms
(9 rows)
</code></pre><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://msdn.microsoft.com/zh-cn/library/ms175972.aspx" target="_blank" rel="noopener">WITH common_table_expression</a></li>
<li><a href="http://doudouclever.blog.163.com/blog/static/175112310201261355984/" target="_blank" rel="noopener">谓词下推</a></li>
<li><a href="http://blog.2ndquadrant.com/postgresql-ctes-are-optimization-fences/" target="_blank" rel="noopener">PostgreSQL’s CTEs are optimisation fences</a></li>
<li><a href="http://dba.stackexchange.com/questions/54388/why-are-the-plans-different-if-the-queries-are-logically-alike" target="_blank" rel="noopener">Why are the plans different if the queries are logically alike?</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/15/2016-11-15-postgresql's-common-table-expressions/" data-id="cjo9s9u91003kbw6xbluwpuj1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/postgresql/">postgresql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-11-14-ruby-2.4.0-preview3" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/14/2016-11-14-ruby-2.4.0-preview3/" class="article-date">
  <time datetime="2016-11-14T00:00:00.000Z" itemprop="datePublished">2016-11-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby/">Ruby</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/14/2016-11-14-ruby-2.4.0-preview3/">Ruby 2.4.0 概览</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Binding-irb-Start-a-REPL-session-like-binding-pry"><a href="#Binding-irb-Start-a-REPL-session-like-binding-pry" class="headerlink" title="Binding#irb: Start a REPL session like binding.pry"></a>Binding#irb: Start a REPL session like binding.pry</h3><p>通常大家在调试的时候会选择使用p打印出变量的值或者使用pry,现在,我们又多了一种方法,通过引入binding.irb,可以启动一个类似如pry的REPL<br>session:</p>
<pre><code>&apos;&apos;&apos;
require &quot;irb&quot;

class Test
  def initialize name
      @name = name
  end

  def say
     binding.irb
     puts &quot;hello,#name&quot;
  end
end

Test.new(&quot;jack&quot;).say

ruby test.rb

#𔓘 Work ruby test.rb

#2.4.0-preview3 :001 &gt; @name
# =&gt; &quot;jack&quot;
#2.4.0-preview3 :002 &gt;
&apos;&apos;&apos;
</code></pre><h3 id="Add-non-ASCII-case-conversion-to-String"><a href="#Add-non-ASCII-case-conversion-to-String" class="headerlink" title="Add non-ASCII case conversion to String"></a>Add non-ASCII case conversion to String</h3><p>字符串增加对非ASCII的操作.</p>
<h3 id="Unify-Fixnum-and-Bignum-into-Integer"><a href="#Unify-Fixnum-and-Bignum-into-Integer" class="headerlink" title="Unify Fixnum and Bignum into Integer"></a>Unify Fixnum and Bignum into Integer</h3><p>CRuby有两种类型的整数类,分别是Integer和Bignum,现在两者合并,所以在Sequel中,应该使用symbol版本的Bignum.</p>
<h3 id="Float-round-with-keyword"><a href="#Float-round-with-keyword" class="headerlink" title="Float#round with keyword"></a>Float#round with keyword</h3><p>Float#round现在支持可选的参数，默认的行为是向最近的偶数取整</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ruby 2.3</span><br><span class="line">(2.5).round</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"># ruby 2.4</span><br><span class="line">(2.5).round</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/14/2016-11-14-ruby-2.4.0-preview3/" data-id="cjo9s9u8y003gbw6xq1ey9a9v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-09-16-distributed-two-phase-commit" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/16/2016-09-16-distributed-two-phase-commit/" class="article-date">
  <time datetime="2016-09-16T00:00:00.000Z" itemprop="datePublished">2016-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/16/2016-09-16-distributed-two-phase-commit/">分布式事物：两阶段提交</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>两阶段提交是指，为了使基于分布式系统架构下的所有节点进行事务提交时保持一致性而设计的一种算法，通常也叫做两阶段提交协议。在分布式系统中，通常一个事务会跨越很多个节点，但是每个节点只能知悉自己的操作是否成功，对于其他节点操作的成功与否无法知晓。所以，为了保持分布式事务提交的ACID特性，需要引入一个组件来统一管理各个节点的操作结果，并最终决定是否要把这些节点的操作结果进行提交。–维基百科</p>
</blockquote>
<p>两阶段提交主要包括一个协调者和数个参与者，在第一阶段中，任何一个参与者可以单方面的终止事务，在第一阶段的末期，所有的参与者都不能单方面的终止事务。<br>具体的步骤如下：</p>
<ul>
<li>提交请求阶段：也称投票阶段，协调者向所有参与者发起询问，参与者如果已经就绪，就回复”ready”，否则就回复”not ready”。后一种情况多发生在并发事务有冲突或者请求超时上。这个阶段，各个参与者并不会真正的提交，而是会将提交的操作写入日志。</li>
<li>提交阶段：<ul>
<li>当所有的参与者都回复”ready”，并且协调者收到消息后，将会对所有的参与者发送”commit”指令，所有的参与者执行事务，并回送”commit ACK”给协调者，协调者收到后，结束事务。</li>
<li>当有任何一个参与者回复”not ready”，并且协调者收到消息后，将会对所有的参与者发送”abort commit”指令，参与者终止事务并回送”abort ACK”，协调者收到后，结束事务。</li>
</ul>
</li>
</ul>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>对节点的容错处理非常脆弱，尤其是协调者出现了错误。</li>
<li>会产生阻塞的情形。虽然2PC追求一致性，但是并不完美。如果锁没有被释放，将会导致数据不可以被访问。</li>
<li>有一个不确定期，无法准确的确定参与者在那一个时间段能够单方面的做决定。</li>
<li>耗时，耗费很多时间在投票表决阶段。</li>
</ul>
<p>使用2PC保证正对所有资源的更新要么都操作要么都不操作，同时也带来了额外的开销，协调操作会对可扩展性，性能以及延迟造成不利影响，当增加依赖的资源和用户基数变大时，这种不利影响会呈几何级扩大。可用性也依赖所有依赖的资源的可用性。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="http://courses.cs.vt.edu/~cs5204/fall00/distributedDBMS/duckett/tpcp.html" target="_blank" rel="noopener">The Two-Phase Commit Protocol</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">两阶段提交</a></li>
<li><a href="https://www.infoq.com/articles/ebay-scalability-best-practices" target="_blank" rel="noopener">Scalability Best Practices: Lessons from eBay</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/16/2016-09-16-distributed-two-phase-commit/" data-id="cjo9s9u8s003cbw6xbxc3dtpr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-09-16-be-careful-with-sequel-when-transfer-from-activerecord" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/16/2016-09-16-be-careful-with-sequel-when-transfer-from-activerecord/" class="article-date">
  <time datetime="2016-09-16T00:00:00.000Z" itemprop="datePublished">2016-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby/">Ruby</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/16/2016-09-16-be-careful-with-sequel-when-transfer-from-activerecord/">使用sequel需要注意的地方</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用<a href="https://github.com/jeremyevans/sequel" target="_blank" rel="noopener">sequel</a>有一段时间了，愈发的觉得这是一个优秀的框架。但是作为一个从ActiveRecord资深使用者切换过来的开发人员，还是多少带有一些习惯性思维在里面，因而容易不恰当的使用一些Sequel的特性。这篇文章的主要目的是记录一些需要注意的地方。</p>
<h4 id="调用first时，采用不同的方法返回的结果的类型并不完全一致"><a href="#调用first时，采用不同的方法返回的结果的类型并不完全一致" class="headerlink" title="调用first时，采用不同的方法返回的结果的类型并不完全一致"></a>调用first时，采用不同的方法返回的结果的类型并不完全一致</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Post.where(:title =&gt; &apos;Hello world&apos;).first.class #=&gt; Post</span><br><span class="line">Post.eager(:author).first.class #=&gt; Post</span><br><span class="line">Post.eager_graph(:author).first.class #=&gt; Hash</span><br></pre></td></tr></table></figure>
<h4 id="没有pluck方法，可用select-map"><a href="#没有pluck方法，可用select-map" class="headerlink" title="没有pluck方法，可用select_map"></a>没有pluck方法，可用select_map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Post.select_map([:id, :title])</span><br></pre></td></tr></table></figure>
<h4 id="没有attribute-names方法"><a href="#没有attribute-names方法" class="headerlink" title="没有attribute_names方法"></a>没有attribute_names方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">album.keys.map&#123;|x| x.to_s&#125;.sort</span><br></pre></td></tr></table></figure>
<h4 id="打印sql语句"><a href="#打印sql语句" class="headerlink" title="打印sql语句"></a>打印sql语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">items.where&#123;price * 2 &lt; 50&#125;.sql</span><br></pre></td></tr></table></figure>
<h3 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h3><p>数据库连接，本质上，就是一个长期的 TCP 连接。通过系统的命令行，可以观察连接。<br>比如在 Linux 使用 ss -anp | grep [端口号]，可以查看指定端口的 TCP 连接数量。Mac 下面的命令是：lsof -i -n -P | grep TCP | grep [端口号]。</p>
<p>对于数据库来说，维护一个应用的 TCP 连接，是需要消耗固定内存，Postgresql 中维护一个连接，耗费的内存是 2 MB。<br>在数据库中，可以通过 SQL 语句，查询连接的状态，以及上一条执行的 SQL 语句，在指定数据库中执行：SELECT * FROM pg_stat_activity;</p>
<p>对于数据库，维护大量的数据库连接，耗费的内存高。</p>
<p>Sequel可以根据设置的时间，关闭数据库连接。在设置数据库连接后设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB.extension(:connection_expiration)</span><br><span class="line">DB.pool.connection_expiration_timeout = 10</span><br></pre></td></tr></table></figure>
<h3 id="Read-Only-Slaves-Writable-Master"><a href="#Read-Only-Slaves-Writable-Master" class="headerlink" title="Read-Only Slaves/Writable Master"></a>Read-Only Slaves/Writable Master</h3><p>需要注意的是事物和存储过程均不能运行在slave机器上，若需要使用，则需要指定master机器。如果想指定某一条查询使用特定的数据库择可以采用这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB[:users].server(:default).all</span><br></pre></td></tr></table></figure>
<p>数据库使用单个主库单个丛库的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB=Sequel.connect(&apos;postgres://master_server/database&apos;,    :servers=&gt;&#123;:read_only=&gt;&#123;:host=&gt;&apos;slave_server&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这条配置会让select查询语句运行在slave机器上，其它的查询运行在master机器上。</p>
<h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><p>由于sequel的设计理念，即使是在transaction块中，select语句和非select语句会在不同的shard中执行。要保证transaction块中的所有语句都在同一个数据库中执行则需要显示的指定server。<br>或者更方便的复写DB.transaction, 主要是利用server_block这个extendion。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB.extensions :server_block</span><br><span class="line">DB.transaction  do</span><br><span class="line">  DB.with_server(:default) do</span><br><span class="line">    -----</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/16/2016-09-16-be-careful-with-sequel-when-transfer-from-activerecord/" data-id="cjo9s9u8q0038bw6xb1daclz6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-09-15-tcp-reset-attack" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/15/2016-09-15-tcp-reset-attack/" class="article-date">
  <time datetime="2016-09-15T00:00:00.000Z" itemprop="datePublished">2016-09-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TCP-IP/">TCP/IP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/15/2016-09-15-tcp-reset-attack/">TCP复位攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>虽然TCP/IP是一个可靠的面向连接的协议，但是仍然有许多的漏洞。本文将要讲解其中的一种: rst复位攻击, 在这之前让我们先回顾一下TCP的基础知识。</p>
<h3 id="TCP概览"><a href="#TCP概览" class="headerlink" title="TCP概览"></a>TCP概览</h3><p>TCP数据报被封装在一个IP数据报中，如图［1］所示。<br><img src="/assets/images/2BE3318E-3915-4602-9E18-5ED74CFCD274.png" alt="Alt &quot;TCP包首部&quot;"></p>
<p>图[2]展示的是TCP首部的数据格式，如果不计任选字段，它将会是20个字节。<br><img src="/assets/images/438E3D81-ADF4-473C-BFED-163687225A04.png" alt="Alt &quot;TCP数据在IP数据报中的封装&quot;"></p>
<p>由图[2]可以清楚的看到TCP数据报的头部包含一个16位的源端口地址和一个16位的目的端口地址，用于寻找发送端和接收端的应用程序。这两个端口号和IP首部中的发送端IP地址和接收端IP地址结合起来就能够唯一确定一个TCP连接。</p>
<h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p>接下来讲解TCP是如何建立连接的，也就是通常所说的三次握手的过程。为了简便起见，我直接使用<code>rails new blog</code>创建一个app，然后运行<code>rails s</code>启动服务，然后本机运行<code>telnet localhost 3000</code>。再开一个窗口运行<code>sudo tcpdump -i lo0 port 3000</code>，得到如下输出。</p>
<pre><code>16:44:23.751241 IP6 localhost.59405 &gt; localhost.hbci: Flags [S], seq 396289691, win 65535, options [mss 16324,nop,wscale 5,nop,nop,TS val 896927289 ecr 0,sackOK,eol], length 0
16:44:23.751315 IP6 localhost.hbci &gt; localhost.59405: Flags [S.], seq 588037038, ack 396289692, win 65535, options [mss 16324,nop,wscale 5,nop,nop,TS val 896927289 ecr 896927289,sackOK,eol], length 0
16:44:23.751331 IP6 localhost.59405 &gt; localhost.hbci: Flags [.], ack 1, win 12743, options [nop,nop,TS val 896927289 ecr 896927289], length 0
16:44:23.751345 IP6 localhost.hbci &gt; localhost.59405: Flags [.], ack 1, win 12743, options [nop,nop,TS val 896927289 ecr 896927289], length 0
16:44:53.758011 IP6 localhost.hbci &gt; localhost.59405: Flags [F.], seq 1, ack 1, win 12743, options [nop,nop,TS val 896957275 ecr 896927289], length 0
16:44:53.758085 IP6 localhost.59405 &gt; localhost.hbci: Flags [.], ack 2, win 12743, options [nop,nop,TS val 896957275 ecr 896957275], length 0
16:44:53.758101 IP6 localhost.hbci &gt; localhost.59405: Flags [.], ack 1, win 12743, options [nop,nop,TS val 896957275 ecr 896957275], length 0
16:44:53.758188 IP6 localhost.59405 &gt; localhost.hbci: Flags [F.], seq 1, ack 2, win 12743, options [nop,nop,TS val 896957275 ecr 896957275], length 0
16:44:53.758260 IP6 localhost.hbci &gt; localhost.59405: Flags [.], ack 2, win 12743, options [nop,nop,TS val 896957275 ecr 896957275], length 0
</code></pre><p>查看第三条可看出客户端的确认序号与描述不符，查阅资料发现正确的telnet命令应该是’sudo tcpdump -i lo0 port 3000 -s’。</p>
<blockquote>
<p>the ack sequence number is a small integer (1). The first time tcpdump sees a tcp ‘conversation’, it prints the sequence number from the packet. On subsequent packets of the conversation, the difference between the current packet’s sequence number and this initial sequence number is printed. This means that sequence numbers after the first can be interpreted as relative byte positions in the conversation’s data stream (with the first data byte each direction being ‘1’). ‘-S’ will override this feature, causing the original sequence numbers to be output.</p>
</blockquote>
<p>改用浏览器直接请求，为避免不必要的干扰仅截取一部分进行说明：</p>
<pre><code>17:31:09.583497 IP6 localhost.59700 &gt; localhost.hbci: Flags [S], seq 608092820, win 65535, options [mss 16324,nop,wscale 5,nop,nop,TS val 899727695 ecr 0,sackOK,eol], length 0
17:31:09.583645 IP6 localhost.hbci &gt; localhost.59700: Flags [S.], seq 2325301428, ack 608092821, win 65535, options [mss 16324,nop,wscale 5,nop,nop,TS val 899727695 ecr 899727695,sackOK,eol], length 0
17:31:09.583673 IP6 localhost.59700 &gt; localhost.hbci: Flags [.], ack 2325301429, win 12743, options [nop,nop,TS val 899727695 ecr 899727695], length 0
</code></pre><p>现在让我们来逐条分析以上的输出来看一下为了建立一条TCP连接要经过那些步骤：</p>
<ul>
<li>客户端首先发送一个SYN段表明其打算连接的服务端的端口以及初始序号ISN（seq 608092820), 此为报文段1。</li>
<li>服务器发回包含服务器的初始序号的SYN(seq 2325301428)（报文段2）, 同时设置确认序号客户端初始序号ISN ＋ 1， ACK ＝ ISN ＋ 1(ack 608092821), 对客户端发送的SYN进行确认。</li>
<li>客户端设置确认序号为服务端初始序号ISN ＋ 1,  ACK ＝ ISN ＋ 1(ack 2325301429), 对服务端的SYN报文段进行确认。</li>
</ul>
<h3 id="RST复位标志"><a href="#RST复位标志" class="headerlink" title="RST复位标志"></a>RST复位标志</h3><p>TCP首部中的RST比特是用于”复位”的，发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。</p>
<h3 id="TCP-Reset-Attacks"><a href="#TCP-Reset-Attacks" class="headerlink" title="TCP Reset Attacks"></a>TCP Reset Attacks</h3><ul>
<li>首先攻击者需要劫持TCP session。</li>
<li>攻击者发送RST标志位置1的包到主机A和主机B，或者二者之一。</li>
<li>因为主机A和主机B并不知道这些包是由攻击者发出的，所以A，B正常的处理这些包。</li>
<li>因为这些包包含RST为1的标志位，所以A和B之间的连接就关闭了。</li>
</ul>
<p>下面我们来讲一下攻击者如何劫持TCP session。</p>
<p>假设主机A和主机B之间已经建立了TCP连接，那么一个攻击者能够监控主机A和主机B之间的数据包, 那么劫持TCP session就可以采用如下步骤：</p>
<ul>
<li>攻击者使用Dos攻击主机B，中断主机B和主机A之间的通信。</li>
<li>现在攻击者就能够预测主机A期望主机B发送的包所包含的序列号。</li>
<li>攻击者准备一个这样的包发送给主机A。</li>
<li>主机A不知道这个包是假冒的，仍然认为该包来自主机B。</li>
<li>攻击者可以利用这个包做出各种神奇的攻击。</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="http://www.thegeekstuff.com/2012/01/tcp-sequence-number-attacks/" target="_blank" rel="noopener">TCP Attacks: TCP Sequence Number Prediction and TCP Reset Attacks</a></li>
<li><a href="http://item.jd.com/10057317.html" target="_blank" rel="noopener">TCP/IP详解卷1: 协议</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/15/2016-09-15-tcp-reset-attack/" data-id="cjo9s9u8p0035bw6xzyu3nzev" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-05-08-two-dimensional-array-vs-pointer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/08/2016-05-08-two-dimensional-array-vs-pointer/" class="article-date">
  <time datetime="2016-05-08T00:00:00.000Z" itemprop="datePublished">2016-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learning-C/">Learning C</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/08/2016-05-08-two-dimensional-array-vs-pointer/">指向二维数组的指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先我们通过一道例题来认识一下指向二维数组的指针。<br>    Code:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int
main()
{
  int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};
  int *p;
  for(p=&amp;a[0][0]; p&lt;&amp;a[0][0]+12;p++)
  {
    cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;endl;
  }
  return 0;
}
</code></pre><p>我们把二维数组存储在内存里面的时候，实际上是把二维数组拉成了一条直线存储在内存里面的。数组里面的每个元素都是连续的存储在内存中的，二维数组也一样，所以我们通过对指针进行＋＋运算的时候，指针会指向下一个元素。</p>
<h3 id="输入i-j-输出a-i-j"><a href="#输入i-j-输出a-i-j" class="headerlink" title="# 输入i,j;输出a[i][j];"></a># 输入i,j;输出a[i][j];</h3><pre><code>Code:
#include &lt;iostream&gt;
using namespace std;
int
main()
{
  int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};
  int (*p)[4],i,j;
  p = a;
  cin&gt;&gt;i&gt;&gt;j;
  cout&lt;&lt;setw(4)&lt;&lt;*(*(p+i)+j);
  return 0;
}
</code></pre><p>首先定义一个二维数组a[3][4]，我们从p=a开始，a相当于指向a[3][4]的第一个元素的指针；所谓的第一个元素是指一个包涵4个int型元素的一维数组；所以a相当于一个包涵4个int型元素的一维数组的地址；如果要定义p的话，p的基类型就是包涵4个int型类型的一维数组。所以我们要定义一个包涵4个int型类型的一维数组的指针变量<code>int (*p)[4]</code>。</p>
<h3 id="利用指针变量引用多维数组中的数组"><a href="#利用指针变量引用多维数组中的数组" class="headerlink" title="# 利用指针变量引用多维数组中的数组"></a># 利用指针变量引用多维数组中的数组</h3><ul>
<li><code>*(*(p+i)+j)</code><br>p指向一个包涵4个int型元素的一维数组，<code>p+i</code>是第<code>i＋1</code>个包涵4个int型元素的一维数组的地址，所以<code>p+i</code>等价于<code>&amp;a[i]</code>。那么很明显的<code>*(p+i)</code>等价于<code>a[i]</code>，<code>*(p+i)+j</code>等价于<code>a[i]+j</code>，因为<code>a[i]+j</code>等价于<code>&amp;a[i][j]</code>，所以<code>*(*(p+i)+j)</code>等价于<code>a[i][j]</code>。</li>
</ul>
<h3 id="指针变量的-操作"><a href="#指针变量的-操作" class="headerlink" title="#  指针变量的++操作"></a>#  指针变量的<code>++</code>操作</h3><pre><code>Code:
#include &lt;iostream&gt;
using namespace std;
int
main()
{
  int a[4] = {1,3,5,7}:
  cout&lt;&lt;a&lt;&lt;endl;
  cout&lt;&lt;a+1&lt;&lt;endl;
  cout&lt;&lt;&amp;a&lt;&lt;endl;
  cout&lt;&lt;&amp;a+1&lt;&lt;endl;
  cout&lt;&lt;*(&amp;a)&lt;&lt;endl;
  cout&lt;&lt;*(&amp;a)+1&lt;&lt;endl;
  return 0;
}
</code></pre><p>对于上面的程序，<code>cout&lt;&lt;a&lt;&lt;endl</code>打印出数组的首地址，<code>+1</code>操作后，打印出首地址的值加4。当我们对一个指向整型的指针变量进行<code>++</code>操作的时候，指针变量的值会增加4，也就是指针变量的基类型的大小。但是当我们对a进行<code>&amp;</code>操作的时候，会将a的管辖范围提升至整个数组，并返回一个指针，所以现在该指针变量的基类型是整个数组，我们再进行<code>+1</code>操作的时候，该指针变量的值会跨越整个数组至下一个地址。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a># 总结</h3><ul>
<li>数组名相当于指向数组的第一个元素的指针</li>
<li>&amp;a是指向整个数组的指针，相当于管辖范围上升了一级</li>
<li><code>*a</code>是数组的第一个元素a[0]，即’*a’相当于a[0],相当于管辖范围降了一级</li>
<li>假定有二维数组a[3][4]，二维数组名相当于指向首元素的指针，二维数组的第一个元素是a[0],a[0]是一个包涵四个整型元素的一维数组。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/08/2016-05-08-two-dimensional-array-vs-pointer/" data-id="cjo9s9u8n0030bw6xb6exwuop" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-05-08-string-vs-pointer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/08/2016-05-08-string-vs-pointer/" class="article-date">
  <time datetime="2016-05-08T00:00:00.000Z" itemprop="datePublished">2016-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learning-C/">Learning C</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/08/2016-05-08-string-vs-pointer/">字符串与指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>字符串常量是一个字符数组，在字符串的内部表示中，字符数组以空字符<code>\0</code>结尾。所以程序可以通过检查空字符找到字符数组的结尾，因此字符串常量存储空间比双引号内的字符数大1。<br>字符串常量和字符数组的区别仅仅在于最后有没有<code>\0</code>。当我们访问字符串时，实际上是通过字符指针进行访问的。<br>    Code:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int
main()
{
  char c[6] = {&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\0&apos;}
  char *pc = c;
  cout&lt;&lt;c&lt;&lt;endl;
  cout&lt;&lt;pc&lt;&lt;endl;
  return 0;
}
</code></pre><p>这里的<code>cout&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;pc&lt;&lt;endl</code>实际上是打印出整个字符串数组，而不是该字符串数组的地址，原因是<code>cout</code>对字符串的输出做了特殊的处理，如果我们要打印出该字符串数组的首地址，应该采用<code>cout&lt;&lt;static_cast&lt;void*&gt;(c)&lt;&lt;endl; cout&lt;&lt;static_cast&lt;void*&gt;(pc)&lt;&lt;endl</code>。</p>
<h3 id="字符串指针举例"><a href="#字符串指针举例" class="headerlink" title="# 字符串指针举例;"></a># 字符串指针举例;</h3><pre><code>Code:
#include &lt;iostream&gt;
using namespace std;
int
main()
{
  char buffer[10] = &quot;ABC&quot;;
  char *pc;
  pc = &quot;hello&quot;;
  cout&lt;&lt;pc&lt;&lt;endl;
  pc++;
  cout&lt;&lt;pc&lt;&lt;endl;
  cout&lt;&lt;*pc&lt;&lt;endl;
  pc = buffer;
  cout&lt;&lt;pc;
  return 0
}
</code></pre><p>我们可以直接把字符串赋给指针变量<code>pc=&quot;hello&quot;</code>，但是不能把字符串赋值给字符数组，除了在初始化的时候。在这里，因为字符串是一个常量，所以我们只能读取该字符串的值，但是不能改变它的值。在程序运行时，所有的常量都是放在一块特殊的内存区域中，这块区域是不允许修改的。在进行<code>pc++</code>后，指针指向下一个位置，因此<code>pc++;cout&lt;&lt;pc&lt;&lt;endl</code>打印出<code>ello</code>, <code>cout&lt;&lt;*pc&lt;&lt;endl</code>打印出<code>e</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/08/2016-05-08-string-vs-pointer/" data-id="cjo9s9u8m002xbw6xs2ayew0c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016-01-03-understanding-javascript-prototype" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/03/2016-01-03-understanding-javascript-prototype/" class="article-date">
  <time datetime="2016-01-03T00:00:00.000Z" itemprop="datePublished">2016-01-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/03/2016-01-03-understanding-javascript-prototype/">理解JavaScript中的原型继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原型是JavaScript的核心概念之一，理解JavaScript的原型就显得尤为重要。在JavaScript中，类的所有对象都从同一个原型对象上继承属性,因此，原型对象是类的核心。</p>
<p>除了null对象之外，每一个JavaScript对象都和另一个对象关联，”另一个”对象就是原型。<br>根据创建对象的方式的不同，对象的原型也不同。举例来讲，通过对象直接创建的对象拥有同一个原型，可以通过Object.prototype来获得对原型对象的引用。通过关键字new和构造函数调用创建的对象就是构造函数的prototype的值。</p>
<p>这里需要指出的一点就是并不是每一个JavaScript对象都有原型，数量虽然不多，但是确实存在，Object.prototype就是其中的一个。</p>
<p>下面让我们用实际的例子来看一下，原型继承到底是如何工作的</p>
<pre><code>Code:
  function Parent(name, job) {
    this.name = name;
    this.job  = job;
  }

  Parent.prototype.getName = function() {
    return this.name;
  }

  Parent.prototype.getJob = function() {
    return this.job;
  }

  var parent = new Parent(&quot;Jack&quot;, &quot;developer&quot;);
  console.log(parent.getName()); //Jack
  console.log(parent.getJob()); //developer

  function Child(name, job) {
    this.name = name;
    this.job  = job;
  }
  Child.prototype = new Parent();

  var child = new Child(&quot;Jones&quot;, &quot;manager&quot;);
  console.log(child.getName());//Jones
  console.log(child.getJob());//manager
</code></pre><p>基本的原型继承是相当简单的，但是这也有一个明显的问题，就是会重复构造函数中的初始化操作,这显然不是我们想看到的。<br>为了简化操作，我们可以在子类的构造函数上做文章。</p>
<pre><code>Code:
function Child(name. job) {
  Parent.apply(this, arguments);
}
</code></pre><h3 id="利用create函数"><a href="#利用create函数" class="headerlink" title="利用create函数"></a>利用create函数</h3><p>这是来自JavaScript大师Douglas Crockford的方法，具体做法是给Object对象增加一个create方法，创建一个使用原对象作为原型的新对象。</p>
<pre><code>Code:
Object.create = function(o) {
  var F = function () {};
  F.prototype = o;
  return new F();
}
</code></pre><p>原型关系是一种动态的关系，如果我们给一个原型添加新的属性，那么新创建的属性会对所有的基于该原型创建的对象可见。</p>
<ul>
<li><a href="http://www.amazon.cn/O-Reilly%25252525252525252525E7%25252525252525252525B2%25252525252525252525BE%25252525252525252525E5%2525252525252525252593%2525252525252525252581%25252525252525252525E5%252525252525252525259B%25252525252525252525BE%25252525252525252525E4%25252525252525252525B9%25252525252525252525A6%25252525252525252525E7%25252525252525252525B3%25252525252525252525BB%25252525252525252525E5%2525252525252525252588%2525252525252525252597-JavaScript%25252525252525252525E6%252525252525252525259D%2525252525252525252583%25252525252525252525E5%25252525252525252525A8%2525252525252525252581%25252525252525252525E6%252525252525252525258C%2525252525252525252587%25252525252525252525E5%252525252525252525258D%2525252525252525252597-%25252525252525252525E5%25252525252525252525BC%2525252525252525252597%25252525252525252525E5%2525252525252525252585%25252525252525252525B0%25252525252525252525E7%25252525252525252525BA%25252525252525252525B3%25252525252525252525E6%25252525252525252525A0%25252525252525252525B9/dp/B007VISQ1Y?SubscriptionId=AKIAJMGEVRIO53UGJCYQ&amp;tag=16-28-282__-23&amp;linkCode=sp1&amp;camp=2025&amp;creative=165953&amp;creativeASIN=B007VISQ1Y" title="JavaScript权威指南(第6版)" target="_blank" rel="noopener">JavaScript权威指南</a></li>
<li><a href="http://www.amazon.cn/JavaScript%2525252525252525E8%2525252525252525AF%2525252525252525AD%2525252525252525E8%2525252525252525A8%252525252525252580%2525252525252525E7%2525252525252525B2%2525252525252525BE%2525252525252525E7%2525252525252525B2%2525252525252525B9-%2525252525252525E9%252525252525252581%252525252525252593%2525252525252525E6%2525252525252525A0%2525252525252525BC%2525252525252525E6%25252525252525258B%252525252525252589%2525252525252525E6%252525252525252596%2525252525252525AF%2525252525252525E2%252525252525252580%2525252525252525A2%2525252525252525E5%252525252525252585%25252525252525258B%2525252525252525E7%2525252525252525BD%252525252525252597%2525252525252525E5%252525252525252585%25252525252525258B%2525252525252525E7%2525252525252525A6%25252525252525258F%2525252525252525E5%2525252525252525BE%2525252525252525B7/dp/B0097CON2S?SubscriptionId=AKIAJMGEVRIO53UGJCYQ&amp;tag=16-28-282__-23&amp;linkCode=sp1&amp;camp=2025&amp;creative=165953&amp;creativeASIN=B0097CON2S" title="JavaScript语言精粹(修订版)" target="_blank" rel="noopener">JavaScript语言精粹</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/03/2016-01-03-understanding-javascript-prototype/" data-id="cjo9s9u8j002tbw6xbs0f1ajv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2015-12-05-using-jssdk-implements-payment" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/05/2015-12-05-using-jssdk-implements-payment/" class="article-date">
  <time datetime="2015-12-05T00:00:00.000Z" itemprop="datePublished">2015-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/weixin/">weixin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/05/2015-12-05-using-jssdk-implements-payment/">使用JSSDK实现微信支付</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近开发微信支付功能时，遇到很多坑，很是一番折腾，本文将记录那些踩过的坑和一些心得。</p>
<p>在文章的开头讲解一些在微信公众平台的配置，这是成功实现微信支付的前提。<br>在微信的支付授权目录页面的提示说只要精确到二级或者三级目录就可以了，但是实际上是不对的。<br>翻阅支付开发文档时就会发现，支付的授权目录要和调起支付的页面精确匹配，文档和表单提示的差异实在让人困惑，<br>这一点不得不让人吐槽。而我在实际开发中发现，要同时配置精确支付目录和精确支付目录的上一级目录才能正确的调起支付。</p>
<p>另外一个需要注意的配置项是在实现签名时要传入的参数，包括<code>appid</code>、<code>key</code>、<code>mch_id</code>。其中<code>app_id</code>为接受支付的公众号的id,<br>‘key’为商户平台的key, <code>mch_id</code>为商户平台的id,一个常见的错误是误将<code>app_secret</code>作为<code>key</code>传入。</p>
<p>为了开发的方便，选择已有的轮子<code>weixin_authorize</code>和<code>wx_pay</code>，关于这两个gem的使用可以参阅项目文档，比较详细了。</p>
<p>这里主要讲一下可能会踩的坑。<br>在生成<code>prepay_id</code>的时候，需要传入<code>notify_url</code>,也就是支付成功后的回调地址。<code>notify_url</code>是不能带有参数的，因为微信会<br>在通知支付结果时将<code>notify_url</code>的传入参数给截掉。比如传入的是<code>a.html?id=3</code>,最后变成了<code>a.html</code>。如果需要传递参数可以在参数<br>放在<code>out_trade_no</code>中，我在开发的时候将多个不同场景下的支付都交给同一个action处理，支付回调也是。这个时候就需要区分到底是<br>来自哪一个场景下的支付，解决方案是在<code>out_trade_no</code>中加一个前缀来进行区分。</p>
<p>另外一个不太常见的场景就是多个公众号公用同一个支付号的场景。这个时候就要获取用户在支付号下的<code>open_id</code>，这里可以选择通过网页授权的形式<br>获取<code>open_id</code>。这里也有一个回调地址，同样的，微信在返回的时候也会截取掉<code>redirect_uri</code>后面的参数，如果你传入多个参数，返回时只剩下一个。<br>所以如果你在支付的页面需要传递多个参数的话，可以将<code>open_id</code>参数的获取提前到一个不需要传递参数的页面进行。在多公众号公用同一个支付号的场景下，所有的参数如<code>app_id</code>、<code>app_secret</code>、<code>mch_id</code>、<code>key</code>都必须是支付号。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/05/2015-12-05-using-jssdk-implements-payment/" data-id="cjo9s9u8i002pbw6xwfrymhaw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rails/">Rails</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weixin/">weixin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2015-11-21-understanding-try-method" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/21/2015-11-21-understanding-try-method/" class="article-date">
  <time datetime="2015-11-21T00:00:00.000Z" itemprop="datePublished">2015-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Rails/">Rails</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/21/2015-11-21-understanding-try-method/">理解Rails中的try方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着<code>ruby-2.3.0-preview1</code>的发布，ruby语言原生的支持安全运算子。那么之前为了解决<code>nil</code>问题创建出来的诸如<code>NullObject</code>、<code>try</code>是不是就没有用了呢？答案是否定的。</p>
<p>在<code>Rails</code>中，经常会有很多的关联关系，这样就会用到链式方法的调用，其中一个不可忽视的问题就是对<code>nil</code>问题的处理。我们来看下面的一个例子,假设我们有一个product，我们要查询该product所属公司的名称，为了防止<code>nil</code>的错误，可能会采用如下写法：</p>
<pre><code>product.try(:company).try(:name)
</code></pre><p>那么使用安全运算符的方式<code>product&amp;.company&amp;.name</code>。</p>
<p>我们来看一下其它的例子：</p>
<pre><code>Ruby Code:
require &quot;rails/all&quot;
class Name
  def say
    p &quot;hello&quot;
  end

  def talk word
    p word
  end
end
</code></pre><p>分别采用安全运算子和<code>try</code>方法进行调用的例子：</p>
<pre><code>Ruby Code:
name = Name.new
name.try(:say) #&quot;hello&quot;
name.try(:talk, &quot;hello&quot;) #&quot;hello&quot;
name.try(:cry) #nil
name&amp;.say #&quot;hello&quot;
name&amp;.cry #NoMethodError: undefined method &apos;cry&apos; for #&lt;Name:0x000000018ada08&gt;
nil&amp;.cry #nil
#带参数的方法没法调用
</code></pre><p>通过以上例子可以发现，当调用者不为<code>nil</code>，而又不能响应被调用的方法时，会抛出<code>NoMethodError</code>的异常。</p>
<p>那么为什么<code>try</code>就能够处理这种情形呢？</p>
<p>  Ruby Code:<br>  class Object<br>    def try(<em>a, &amp;b)<br>      try!(</em>a, &amp;b) if a.empty? || respond_to?(a.first)<br>    end</p>
<pre><code>def try!(*a, &amp;b)
  if a.empty? &amp;&amp; block_given?
    if b.arity.zero?
      instance_eval(&amp;b)
    else
      yield self
    end
  else
    public_send(*a, &amp;b)
  end
end
</code></pre><p>  end</p>
<p>阅读源码可以发现，Rails扩展了<code>Object</code>对象，提供了<code>try</code>方法，可以接受多个参数和一个代码块。<br>参数为空或者调用者能够响应第一个参数时，就交给<code>try!</code>方法处理。</p>
<ol>
<li><code>try</code>方法首先判断参数为空和给定了代码块的情况<ul>
<li>如果代码块不带参数，则直接执行代码块</li>
<li>如果代码块带参数则把调用者作为参数传递给代码块</li>
</ul>
</li>
<li>否则直接交给<code>public_send</code>方法处理,把第一个参数作为被调用的方法，其余的参数作为被调用方法的参数</li>
</ol>
<p><code>Rails</code>同时扩展了<code>NilClass</code>,调用<code>try</code>方法直接返回<code>nil</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/21/2015-11-21-understanding-try-method/" data-id="cjo9s9u8g002lbw6xo1edbq7j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rails/">Rails</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DDD/">DDD</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Learning-C/">Learning C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rails/">Rails</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP/">TCP/IP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Test/">Test</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/best-practices/">best-practices</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-pattern/">design-pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/postgresql/">postgresql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/weixin/">weixin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDD/">DDD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rails/">Rails</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rspec/">Rspec</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Server/">Server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weixin/">weixin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/测试/">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 12.86px;">C</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/DDD/" style="font-size: 10px;">DDD</a> <a href="/tags/Git/" style="font-size: 11.43px;">Git</a> <a href="/tags/Go/" style="font-size: 18.57px;">Go</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 17.14px;">JavaScript</a> <a href="/tags/Rails/" style="font-size: 14.29px;">Rails</a> <a href="/tags/Rspec/" style="font-size: 10px;">Rspec</a> <a href="/tags/Ruby/" style="font-size: 20px;">Ruby</a> <a href="/tags/Server/" style="font-size: 10px;">Server</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/postgresql/" style="font-size: 12.86px;">postgresql</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/weixin/" style="font-size: 11.43px;">weixin</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/设计模式/" style="font-size: 15.71px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/14/2018-04-14-gokit-learning-one/">go-kit学习笔记(一)</a>
          </li>
        
          <li>
            <a href="/2018/04/14/2018-04-14-gokit-introduction/">go-kit简介</a>
          </li>
        
          <li>
            <a href="/2018/04/14/2018-04-14-golang-context/">golang中context包详解</a>
          </li>
        
          <li>
            <a href="/2018/03/31/2018-03-31-golang-handle-and-handlefunc/">Golang中的Handle和HandleFunc</a>
          </li>
        
          <li>
            <a href="/2018/03/30/2018-03-30-golang-http-router/">Golang中的router</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>